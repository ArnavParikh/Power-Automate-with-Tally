I began by understanding the initially received flows for both the Main and Balance Sheet modules. These flows relied on image-based waits for synchronizing with Tally, which caused usability issues across different systems. To address this, I replaced the image-based waits with fixed time-based waits. Since Tally is an offline desktop application, it is guaranteed to load eventually, making static wait times a more reliable and consistent approach.
In the Main module, user input was initially being taken as plain text for dates, which posed a problem when the format didn’t match the required dd/mm/yyyy format. To resolve this, I switched to using a proper date input field, ensuring format uniformity and preventing flow failures. I also corrected the export path input prompt to clearly ask the user to "Add path where the data will be exported." Furthermore, I added a feature to halt the flow with a display message if the user clicks "Cancel" on any input field.
Initially, the data collection in Balance Sheet was hardcoded to start from 1st April and end at 31st March of the following year, irrespective of user input. I modified this logic to dynamically pick up the actual user-defined start and end dates, including both month and year. To implement this, I first used nested if-else conditions, but that caused significant slowdowns. I optimized the logic using switch-case structures based on month input, which improved the speed considerably.
However, to further streamline the process and eliminate unnecessary branching, I later replaced the switch-case logic with a unified list-based approach. I created a list containing all month abbreviations in order (["jan", "feb", ..., "dec"]). This allowed users to input dates in the format apr-2024, which made it possible to use two simple while loops for iteration over months, completely removing the need for conditionals. This method was also chosen to handle leap year scenarios—particularly the edge case of February 29—without requiring additional leap year checks. It resolved a key issue, as date inputs like 4-2024 were not easily supported, whereas apr-2024 is valid and more readable. Depending on the module, the flow now uses the first or last day of the month as needed.
The Profit & Loss module followed a nearly identical structure to the Balance Sheet and required only minor changes. The Sundry Creditors and Debtors modules also followed the same logic, with a few extra lines of code added to customize them as required.
The Day Book module needed a different approach for data collection since it required full-range data rather than month-wise. I made adjustments to fetch the entire range at once and implemented the necessary code changes. Initially, I used similar logic for the Cash Flow module, but upon comparing the output format, I realized that the data needed to be segmented month-wise instead. I restructured the flow accordingly.
For the Sales and Purchase Analysis reports, I maintained the month-wise data collection logic. While validating the output, I found that the reports had multiple unnecessary columns and were missing some required ones. I referred to the SOS documentation and further explored Tally. I discovered that in the columnar view (accessed via F8 in Sales Analysis), it is possible to manually configure "Type of Column" and "Name of Account" to extract specific Groups or Ledgers. By default, the setting remains at "All items (automatic columns)" even when it’s not visibly displayed. Once required fields are added and "End of List" is selected, only those columns are reflected in the report.

